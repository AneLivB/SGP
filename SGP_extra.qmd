---
title: "Sustainable genetics project: EXTRA"
subtitle: "Script"
author: "Ane Liv Berthelsen"

format:
  html: 
  #pdf: 
    papersize: "a4paper"
    toc: true
    toc-depth: 3
    toc-title: "Contents"
    number-sections: FALSE
    documentclass: article
    geometry:
      - inner=3cm
      - outer=3cm
      - top=2cm
      - bottom=3cm
      - headsep=22pt
      - headheight=11pt
      - footskip=33pt
      - ignorehead
      - ignorefoot
      - heightrounded
    fig-pos: 'h'
    fig-cap-location: bottom
    tbl-cap-location: top
editor: visual
date: 11/20/2023
mainfont: Times New Roman
---

## Functions
```{r}
#| label: Gapfilling
#| echo: FALSE

# #This function can be used to locate the plates that needs to be gapfilled
# Failed_loci <- function(DF1){
#   #mix 1
#   Pv9 <- sum(is.na(select(DF1, contains("Pv9"))))
#   Hg.6.3 <- sum(is.na(select(DF1, contains("Hg.6.3"))))
#   Hg.8.10 <- sum(is.na(select(DF1, contains("Hg.8.10"))))
#   Hg.1.3 <- sum(is.na(select(DF1, contains("Hg.1.3"))))
#   M11a <- sum(is.na(select(DF1, contains("M11a"))))
#   PvcA <- sum(is.na(select(DF1, contains("PvcA"))))
#   Zcwb07 <- sum(is.na(select(DF1, contains("Zcwb07"))))
#   Agaz2 <- sum(is.na(select(DF1, contains("Agaz2"))))
#   loci_m1 <- as.data.frame(rbind(Pv9, Hg.6.3, Hg.8.10, Hg.1.3, M11a, PvcA, Zcwb07, Agaz2))
#   loci_m1$Mix <- "Mix1"
#   #mix 2
#   Ag3 <- sum(is.na(select(DF1, contains("Ag3"))))
#   Agaz6 <- sum(is.na(select(DF1, contains("Agaz6"))))
#   OrrFCB7 <- sum(is.na(select(DF1, contains("OrrFCB7"))))
#   Ag2 <- sum(is.na(select(DF1, contains("Ag2"))))
#   OrrFCB2 <- sum(is.na(select(DF1, contains("OrrFCB2"))))
#   Lw10 <- sum(is.na(select(DF1, contains("Lw10"))))
#   ZcwCO1 <- sum(is.na(select(DF1, contains("ZcwCO1"))))
#   Agaz5 <- sum(is.na(select(DF1, contains("Agaz5"))))
#   ZcwDhB <- sum(is.na(select(DF1, contains("ZcwDhB"))))
#   loci_m2 <- as.data.frame(rbind(Ag3, Agaz6, OrrFCB7, Ag2, OrrFCB2, Lw10, ZcwCO1, Agaz5, ZcwDhB))
#   loci_m2$Mix <- "Mix2"
#   #mix 3
#   ZcwDz301 <- sum(is.na(select(DF1, contains("ZcwDz301"))))
#   Ag7 <- sum(is.na(select(DF1, contains("Ag7"))))
#   Ag.10 <- sum(is.na(select(DF1, contains("Ag.10"))))
#   ZcwDh4 <- sum(is.na(select(DF1, contains("ZcwDh4"))))
#   ZcwE05 <- sum(is.na(select(DF1, contains("ZcwE05"))))
#   Ag1 <- sum(is.na(select(DF1, contains("Ag1"))))
#   OrrFCB8 <- sum(is.na(select(DF1, contains("OrrFCB8"))))
#   Agt.47 <- sum(is.na(select(DF1, contains("Agt.47"))))
#   loci_m3 <- as.data.frame(rbind(ZcwDz301, Ag7, Ag.10, ZcwDh4, ZcwE05, Ag1, OrrFCB8, Agt.47))
#   loci_m3$Mix <- "Mix3"
#   #mix 4
#   ZcwF07 <- sum(is.na(select(DF1, contains("ZcwF07"))))
#   ZcwD02 <- sum(is.na(select(DF1, contains("ZcwD02"))))
#   ZcwCgDh1 <- sum(is.na(select(DF1, contains("ZcwCgDh1"))))
#   Aa4 <- sum(is.na(select(DF1, contains("Aa4"))))
#   ZcCgDH5.8 <- sum(is.na(select(DF1, contains("ZcCgDH5.8"))))
#   Agaz3 <- sum(is.na(select(DF1, contains("Agaz3"))))
#   loci_m4 <- as.data.frame(rbind(ZcwF07, ZcwD02, ZcwCgDh1, Aa4, ZcCgDH5.8, Agaz3))
#   loci_m4$Mix <- "Mix4"
#   #mix 5
#   X962.1 <- sum(is.na(select(DF1, contains("X962.1"))))
#   X554.6 <- sum(is.na(select(DF1, contains("X554.6"))))
#   ZcwA12 <- sum(is.na(select(DF1, contains("ZcwA12"))))
#   PvcE <- sum(is.na(select(DF1, contains("PvcE"))))
#   ZcwB09 <- sum(is.na(select(DF1, contains("ZcwB09"))))
#   Agaz10 <- sum(is.na(select(DF1, contains("Agaz10"))))
#   Mang44 <- sum(is.na(select(DF1, contains("Mang44"))))
#   Mang36 <- sum(is.na(select(DF1, contains("Mang36"))))
#   loci_m5 <- as.data.frame(rbind(X962.1, X554.6, ZcwA12, PvcE, ZcwB09, Agaz10, Mang44, Mang36))
#   loci_m5$Mix <- "Mix5"
#   #Create the output
#   Rack <- deparse(substitute(DF1))
#   Samples <- 95
#   Output <- as.data.frame(rbind(loci_m1,loci_m2, loci_m3, loci_m4, loci_m5))
#   colnames(Output) <- c("Unscored", "Mix")
#   Rack <- deparse(substitute(DF1))
#   Output$Rack <- Rack
#   #Calculates the percentage of unscored loci rounded to 2 digits
#   Output$Percent <- as.numeric((as.numeric(Output$Unscored)/Samples*0.5)*100) %>%
#     round(., 2)
#   Output$Loci <- rownames(Output)
#   #return(Output)
#   #alternatively if only interested in failed loci, loci with more than 20% NAs
#   Find_failed_loci <- subset(Output, Output$Percent > 20)
#   rownames(Find_failed_loci) <- NULL
#   return(Find_failed_loci)
# }
# 
# #apply failed_loci function to all racks to locate which plates needs gapfilling
# Gapfilling <- rbind(Failed_loci(R154_R1),
#                           Failed_loci(R154_R2),
#                           Failed_loci(R154_R3),
#                           Failed_loci(R154_R4),
#                           Failed_loci(R155_R1),
#                           Failed_loci(R155_R2),
#                           Failed_loci(R155_R3),
#                           Failed_loci(R155_R4),
#                           Failed_loci(R156_R1),
#                           Failed_loci(R156_R2),
#                           Failed_loci(R156_R3),
#                           Failed_loci(R156_R4))
# Gapfilling <- Gapfilling[order(Gapfilling$Rack,Gapfilling$Mix ),]
# 
# #saves the table in the correct folder
# write_csv(Gapfilling, file.path(tabs_dir, "Gapfilling.csv"))
```


## Scrip snippets

```{r}
#| label: Unscoreddata
#| echo: FALSE
#Function to calculate the per individual number of NAs
Total_NA <- function(R1, R2, R3, R4) {
    Base <- rbind(R1[1:2], R2[1:2], R3[1:2], R4[1:2])
   colnames(Base) <- c("Well", "ID")
   #Replace Nas with 1 across the whole rack
    #sum is no. of times NA occurs in that row
    R1 <- R1[3:80] %>% replace(!is.na(.), 0) %>% replace(is.na(.), 1) %>%
  mutate(Row_Sums = rowSums(across(everything()))) 
    R2 <- R2[3:80] %>% replace(!is.na(.), 0) %>% replace(is.na(.), 1) %>%
  mutate(Row_Sums = rowSums(across(everything()))) 
    R3 <- R3[3:80] %>% replace(!is.na(.), 0) %>% replace(is.na(.), 1) %>%
  mutate(Row_Sums = rowSums(across(everything())))
    R4 <- R4[3:80] %>% replace(!is.na(.), 0) %>% replace(is.na(.), 1) %>%
  mutate(Row_Sums = rowSums(across(everything()))) 
    
  NAs <- rbind(R1[,c(1,2,79)], R2[,c(1,2,79)], R3[,c(1,2,79)], R4[,c(1,2,79)])
  colnames(NAs) <- c("Well", "ID", "NAs")
  Base$NAs <- NAs$NAs
  return(Base)
}
 
Nasmissing <- as.data.frame(rbind(Total_NA(R154_R1, R154_R2, R154_R3, R154_R4), Total_NA(R155_R1, R155_R2, R155_R3, R155_R4), Total_NA(R156_R1, R156_R2, R156_R3, R156_R4)))

#Histogram
# Nasmissing.plot <- ggplot(Nasmissing, aes(x=NAs)) +
#  geom_histogram(binwidth=.5, colour="black", fill="purple") +
#  ggtitle("Missing data per individual per rack") +
#  ylab("No. of indivuals") +
#  xlab("No. of NAs") +
#  theme_bw()
# 
# ggsave(plot = Nasmissing.plot, filename = file.path(figs_dir, "Nasmissing.png"), width = 30, height = 20, unit = "cm", dpi = 500)

More_than_10 <- subset(Nasmissing, NAs > 10)
#Maybe_exclude <- table(More_than_10$ID)

#unique(Analysis.data$Loci)
```


```{r}
Mismatch <- function(DF1, DF2){
  #Name of the plates 
  Rack_1 <- deparse(substitute(DF1))
  Rack_2 <- deparse(substitute(DF2))
  
  if (Rack_1 == "R154_R1") {
    #On plate R154 the samples in 4th and 5th row are not part of the analysis
     DF1 <- DF1[-(4:5),]
     DF2 <- DF2[-(4:5),]
  } else if (Rack_1 == "R156_R1"){
      #The repeats are not consistent across all plates, so we remove them
      DF1 <- DF1[-(1:2),]
      DF2 <- DF2[-(1:2),]
  } else {
    DF1 <- DF1
    DF2 <- DF2
  }
  
  #To recognize treatment, simplify the 'name' of the DF to the round number (R*)
  Round <- gsub("R\\d{3}|_", "", Rack_2)
  if (Round == "R2"){
    Treatment <- "Internal control"
  } else if (Round == "R3") {
    Treatment <- "Re-used detection plate"
  } else {
    Treatment <- "Re-used PCR plate"
  }
  
  #locate the mismatches by comparing the two data frames and count them
  mismatches <- which(DF1 != DF2, arr.ind = TRUE)
  Total_mismatches <- length(mismatches[,1])
  
  #The allelic error rate is calculated by dividing the number of errors with 
  #the total number of comparision made between the two dataframes
  Total_comparisons <- sum(!is.na(DF1[3:80]) & !is.na(DF2[3:80]))
  #cat("Total mismatches between", Rack_1 ,"and", Rack_2, "=", Total_mismatches)
  Error_rate <- Total_mismatches/Total_comparisons  
  
  #We are also interested in the genotype error rate
  rowid <- subset(mismatches, mismatches[,1] == mismatches[anyDuplicated(mismatches[,1])])
  locimatch <- ifelse(rowid[,2] %in% (rowid[,2]+1), 1, 0)
  Total_genotype_errors <- (length(mismatches[,1])-sum(locimatch))
  Error_rate_genotype <- Total_genotype_errors/(Total_comparisons/2) 
  #The Output is a data frame with the results
  Output <- as.data.frame(cbind(Rack_1, Rack_2, Treatment, Total_mismatches, Error_rate, Error_rate_genotype)) %>%
         mutate(Total_mismatches = as.numeric(Total_mismatches),
         Error_rate = as.numeric(Error_rate), Error_rate_genotype = as.numeric(Error_rate_genotype))
  colnames(Output) <- c("Rack 1", "Rack 2", "Treatment", "No. of mismatches", "Allelic error rate", "Genotype error rate")
  #return(Output)
  
  #Second output element! # out return statement when not in use. 
  #The ID of the individual with the mismatch and the loci werein the mismatch happend 
  #is bound together to ease location 
  ID <- cbind(DF1$mix1.ID[mismatches[, 1]])
  Loci <- cbind(colnames(DF1)[mismatches[, 2]])
  Find_mismatch <- cbind(ID, Loci, Rack_2, Treatment)
  return(Find_mismatch)
}

#The following applies the mismatch function to the chosen racks and binds the output together
#The output contains the location of the mismatches
# Find_mismatches <- rbind(
#  Mismatch(R154_R1, R154_R2),
#  Mismatch(R154_R1, R154_R3),
#  Mismatch(R154_R1, R154_R4),
#  Mismatch(R155_R1, R155_R2),
#  Mismatch(R155_R1, R155_R3),
#  Mismatch(R155_R1, R155_R4),
#  Mismatch(R156_R1, R156_R2),
#  Mismatch(R156_R1, R156_R3),
#  Mismatch(R156_R1, R156_R4))

# Find_mismatches <- as.data.frame(Find_mismatches)
# write_csv(Find_mismatches, file.path(tabs_dir, "Locate_mismatches.csv"))
# Lociwmismatch <- length(unique(Find_mismatches$V2)) #36
# #Alleles.mismatches was 65
# Find_mismatches$V2 <- gsub("_a", "", Find_mismatches$V2)
# Find_mismatches$V2 <- gsub("_b", "", Find_mismatches$V2)
# Count.loci <- as.data.frame(table(Find_mismatches$V2))
# Count.loci$Mix <- substring(Count.loci$Var1, 1, 4)
# Count.loci$Var1 <- gsub("mix\\d{1}.", "", Count.loci$Var1)
# 
# OrangePurple <- c("#FF6600", "#FF9900", "#FF9999", "#CC33FF", "#9900CC")
# Mismatchloci <- Count.loci %>%
#   mutate(Var1 = fct_reorder(Var1, Mix)) %>%
#   ggplot( aes(y=Freq, x = Var1, fill = Mix)) +
#   geom_bar(stat = "identity", position = position_dodge(0.7), width = 0.5, alpha = 0.8) +
#   #scale_fill_brewer(palette = "PuOr") +
#   scale_fill_manual(values=OrangePurple) +
#   scale_x_discrete(guide = guide_axis(angle = 90)) + #turns the x axis label names
#   #guides(fill = F, scale = "none") + #remove the legend
#   ylim(0,65) +
#   ggtitle("Total no. of mismatches per locus") +
#   ylab("Frequency") +
#   xlab("Locus") +
#   theme_bw()
# ggsave(plot = Mismatchloci, filename = file.path(figs_dir, "Mismatchloci.png"), width = 15, height = 10, unit = "cm", dpi = 500)
```

#Maybe useful code
```{r}
#| label: Maybeusablecode
#| echo: FALSE


# # Plot the model
# #Extract info from model output
# model_interval <- mcmc_intervals_data(model.match)
# model_interval <- subset(model_interval, !grepl("b_intercept", parameter))
# model_interval <- subset(model_interval, grepl("b_", parameter))
# model_interval <- model_interval %>% mutate(parameter = case_when(
#   parameter == "b_Intercept" ~ "Internal control",
#   parameter == "b_TreatmentReMuseddetectionplate" ~ "Reused detection plate",
#   parameter == "b_TreatmentReMusedPCRplate"  ~ "Reused PCR plate",
#   parameter == "b_Nanodrop" ~ "Nanodrop"))
# 
# #The parameters are always in relation to the intercept, so to represent them correctly visually
# #the intercept value is added to the parameter values
# Intercept <- subset(model_interval[1,], select = c("ll", "l", "m", "h", "hh"))
# 
# model_interval <- cbind(subset(model_interval[1:4]), rbind(subset(model_interval[1,], select = c("ll", "l", "m", "h", "hh")),
#                 subset(model_interval[2,], select = c("ll", "l", "m", "h", "hh"))+Intercept,
#                 subset(model_interval[3,], select = c("ll", "l", "m", "h", "hh"))+Intercept,
#                 subset(model_interval[4,], select = c("ll", "l", "m", "h", "hh"))+Intercept))
# 
# #area (for density clouds)
# model_info <- mcmc_areas_data(model.match)
# model_info <- subset(model_info, !grepl("b_intercept", parameter))
# model_info <- subset(model_info, grepl("b_", parameter))
# model_info <- model_info %>% mutate(parameter = case_when(
#   parameter == "b_Intercept" ~ "Internal control",
#   parameter == "b_TreatmentReMuseddetectionplate" ~ "Reused detection plate",
#   parameter == "b_TreatmentReMusedPCRplate"  ~ "Reused PCR plate",
#   parameter == "b_Nanodrop" ~ "Nanodrop"))
# 
# #Build the plot
# Density.match.plot <- ggplot(data = subset(model_info, parameter == c("Reused detection plate", "Reused PCR plate"))) +
#   aes(x = x+5.966920, y = parameter) +
#   geom_ridgeline(aes(scale = 0.4, height = scaled_density, fill = parameter, col = parameter), size = 0.9) +
#   geom_ridgeline(data = subset(model_info, parameter == "Internal control"), aes(x = x, y = parameter, scale = 0.4, height = scaled_density, fill = parameter, col = parameter), size = 0.9) +
#   geom_segment(data = subset(model_interval, parameter != "Nanodrop"), aes(x = l, xend = h, yend = parameter), col = "black", size=2) +
#   geom_segment(data = subset(model_interval, parameter != "Nanodrop"), aes(x = ll, xend = hh, yend = parameter), col = "black") +
#   geom_point(data = subset(model_interval, parameter != "Nanodrop"), aes(x = m, y = parameter), color="black", fill = "grey60", shape=21, size = 3) +
#   geom_vline(xintercept = 5.966920, col = "#ca562c", linetype="longdash")+
#   guides(fill = F, scale = "none") + #remove the legend
#   scale_fill_brewer(palette = "Oranges") +
#   scale_color_brewer(palette = "Oranges") +
#   ggtitle("Uncertainty from posterior draws") +
#   ylab("Treatment") +
#   xlab("Posterior distribution") +
#   theme_bw() +
#   theme(legend.position = "none")

# ggsave(plot = Density.match.plot, filename = file.path(figs_dir, "Density.match.plot.png"), width = 15, height = 10, unit = "cm", dpi = 500)
# 

# model.match <- brms::brm(Match ~ Treatment + Nanodrop + (1|ID) + (1|Rack) + (1|Loci) + (1|Mix),
#              data = Analysis.data,
#              family = bernoulli,
#              cores = 10,
#              iter = 1000*r,
#              thin = r,
#              warmup = 500*r, #standard is iter/2
#              chains = 3,
#              set_prior("normal(0,1)", class = "b"))


  #  #Mismatch should also include NA values
  #  NaDF1 <- DF1[3:80] %>% replace(!is.na(.), 0) %>% replace(is.na(.), 1) %>%
  # mutate(Row_Sums = rowSums(across(everything())))
  #  NaDF2 <- DF2[3:80] %>% replace(!is.na(.), 0) %>% replace(is.na(.), 1) %>%
  # mutate(Row_Sums = rowSums(across(everything())))
  #  #sum is no. of times NA occurs in that row
  #  Base$Sum <- as.numeric(NaDF1$Row_Sums) + as.numeric(NaDF2$Row_Sums)
  #  
  #  #NAdetected coded as 1 for no NAs and 0 for NA values
  #  Base$NAdetected <- ifelse(Base$Sum > 0, 0, 1)
  #  #Added with the match information, we can asses complete matches
  #  Base$Match.na <- Base$NAdetected + Base$Match 
  #  Base$Match.na <- ifelse(Base$Match.na != 2, 0, 1)
   
   

# Row1 <- R154_R1[grep('A\\d', R154_R1$mix1.ID), ] %>% 
#   select(contains("Mix1")) %>%
#   replace(is.na(.), 0) %>%
#   as.data.frame() %>%
#   mutate_all(~ ifelse(. == '0', 0, 1)) %>%
#   mutate(Row_Sums = rowSums(.[3:18])) %>%
#   pull(Row_Sums)
# Row2 <- R154_R1[grep('B\\d', R154_R1$mix1.ID), ] %>% 
#   select(contains("Mix1")) %>%
#   replace(is.na(.), 0) %>%
#   as.data.frame() %>%
#   mutate_all(~ ifelse(. == '0', 0, 1)) %>%
#   mutate(Row_Sums = rowSums(across(everything()))) %>%
#   pull(Row_Sums)
# Row3 <- R154_R1[grep('C\\d', R154_R1$mix1.ID), ] %>%   
#   select(contains("Mix1")) %>%
#   replace(is.na(.), 0) %>%
#   as.data.frame() %>%
#   mutate_all(~ ifelse(. == '0', 0, 1)) %>%
#   mutate(Row_Sums = rowSums(across(everything()))) %>%
#   pull(Row_Sums)
# Row4 <- R154_R1[grep('D\\d', R154_R1$mix1.ID), ] %>%   
#   select(contains("Mix1")) %>%
#   replace(is.na(.), 0) %>%
#   as.data.frame() %>%
#   mutate_all(~ ifelse(. == '0', 0, 1)) %>%
#   mutate(Row_Sums = rowSums(across(everything()))) %>%
#   pull(Row_Sums)
# Row5 <- R154_R1[grep('E\\d', R154_R1$mix1.ID), ] %>%   
#   select(contains("Mix1")) %>%
#   replace(is.na(.), 0) %>%
#   as.data.frame() %>%
#   mutate_all(~ ifelse(. == '0', 0, 1)) %>%
#   mutate(Row_Sums = rowSums(across(everything()))) %>%
#   pull(Row_Sums)
# Row6 <- R154_R1[grep('F\\d', R154_R1$mix1.ID), ] %>%   
#   select(contains("Mix1")) %>%
#   replace(is.na(.), 0) %>%
#   as.data.frame() %>%
#   mutate_all(~ ifelse(. == '0', 0, 1)) %>%
#   mutate(Row_Sums = rowSums(across(everything()))) %>%
#   pull(Row_Sums)
# Row7 <- R154_R1[grep('G\\d', R154_R1$mix1.ID), ] %>%   
#   select(contains("Mix1")) %>%
#   replace(is.na(.), 0) %>%
#   as.data.frame() %>%
#   mutate_all(~ ifelse(. == '0', 0, 1)) %>%
#   mutate(Row_Sums = rowSums(across(everything()))) %>%
#   pull(Row_Sums)
# Row8 <- R154_R1[grep('H\\d', R154_R1$mix1.ID), ] %>%
#   select(contains("Mix1")) %>%
#   replace(is.na(.), 0) %>%
#   as.data.frame() %>%
#   mutate_all(~ ifelse(. == '0', 0, 1)) %>%
#   mutate(Row_Sums = rowSums(across(everything()))) %>%
#   pull(Row_Sums)
# 
# Missing_data <- as.data.frame(rbind(Row1, Row2, Row3, Row4, Row5, Row6, Row7, Row8))
# #Missing_data <- matrix(as.numeric(unlist(Missing_data)),nrow=nrow(Missing_data))
# #heatmap(Missing_data, Rowv = NA, Colv = NA)
# Missing_data$row <- rbind("row1", "row2", "row3", "row4", "row5", "row6", "row7", "row8")
```
