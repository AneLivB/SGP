---
title: "Sustainable genetics project"
author: "Ane Liv Berthelsen"
format:
  html: 
  #pdf: 
    toc: true
    #toc-depth: 2
    #toc-title: "Contents"
    number-sections: FALSE
    #documentclass: article
    #geometry:
    #  - top=30mm
    #  - left=30mm
    #  - heightrounded
editor: visual
date: 11/20/2023
toc: true
number-sections: true
mainfont: Times New Roman
---

```{r}
#| label: setup
#| echo: FALSE

#This code chunk is dedicated to variables containing the path to the folder related to the project. 
figs_dir <- file.path("Results", "Figures")
tabs_dir <- file.path("Results", "Tables")

#remember to add a line that saves the figures and tables in the correct folder
#e.g. write_csv(., file.path(tabs_dir, "name of table"))
#e.g. ggsave(plot = name_of_plot, filename = file.path(figs_dir, "name of figure")), width = 19, height = 19, unit = "cm", dpi = 500)
```

# Description

Scientific research is a massive endeavor, consuming vast quantities of single-use plastics. The sustainable genetics project aim to empirically test the re-usability of lab plastic wear, specifically the plastic racks used for PCRs and detection. The project was based around the protocol for Antarctic fur seal genotyping using microsatellites. In this protocol, extracted DNA is first amplified using PCR and since transfered to detection plates for sequencing. The plates used for detection contain only a small diluted concentration of DNA, while the PCR plates have been used in the PCR process and therefore contain a high concentration of DNA. Therefore, we assume that the potential risk of contamination from a previously used plate would be higher in the PCR step.

### Packages

```{r}
#| label: packages
#| echo: FALSE
#here::here()
invisible(pacman::p_load(dplyr, tidyverse, here, stringi, png, knitr, rstatix, cowplot))
```

# Methods

The 274 samples were collected from Bird Island, South Georgia (54째00024.800 S, 38째03004.100 W) during the austral summer of 2020-2021. Tissue samples were collected from the flipper or umbilical cord of Antarctic fur seal pups and stored in 20% dimethyl sulphoxide saturated with sodium chloride at -20째C. The DNA was extracted using a standard chloroform-isoamylalcohol protocol and genotyped at 39 microsatellite loci separated into 5 mixes for improved scoring. PCR amplification was performed using a Type It Kit (Qiagen) with the following program:

| Stage | No. of cycles | Temperature (째C) | Duration   | Process      |
|-------|---------------|------------------|------------|--------------|
| 1     | 1             | 94               | 5 minutes  | Heat up      |
| 2     | 28            | 94               | 30 seconds | Denaturation |
|       |               | 60/53            | 90 seconds | Annealing    |
|       |               | 72               | 30 seconds | Extension    |
| 3     | 1             | 60/53            | 30 minutes | Annealing    |
| 4     | 1             | 10               | hold       | Cool down    |

: PCR program {#tbl-PCR}

*Note: Annealing temperatures are mastermix-specific.*

The PCR product was transferred to and diluted on detection plates before being resolved by electrophoresis on an ABI 3730xl capillary sequencer (Applied Biosystems, Waltham, MA, USA). Each plate contained three positive controls to ensure standardisation of microsatellite scoring across plates. Allele sizes were scored automatically using GeneMarker v. 2.6.2 (SoftGenetics, LLC., State College, PA, USA) and manually inspected and corrected when necessary.

To assess the re-usability of both PCR plates and detection plates, the samples were placed on a master plate from which the samples were transferred to PCR plates. The samples were distributed on a total of 3 master plates. The samples were subjected to four treatments: standard procedure, internal control, re-used PCR plate and re-used detection plate. This is illustrated by @fig-Schematic. The re-used plates all originated from the 'standard procedure' round. Thereby, we could ensure knowledge of the sample previously contained within a specific well. Following standard procedure, any locus with more than 20% missing data is gapfilled separately to minimize missing data.

![Schematic overview](Results/Figures/SGP_setup.png){#fig-Schematic fig-align="center" width="500"}

#### Washing protocol

After the initial use, the racks were washed using the following steps. First, each plate was individually rinsed with distilled water and emptied 10 times, before submerging in soap water for two hours. After soaking, each plate was again rinsed and emptied before left on a paper towel over night to dry.

#### Quantification of genotyping errors

To estimate the genotyping error rate, the 'standard procedure' treatment was first compared to the 'internal control' treatment to establish a baseline error rate. Any discrepancy between the two sets of genotypes was flagged as an error. The error rate was evaluated both for each allele and for the genotype on a locus-specific level and across all loci. After establishing a baseline error rate, the same comparision was preformed between the 'standard procedure' treatment and the two re-use treatments independently. In these cases, any discrepancy was first explored for the possibility of contamination, before flagged as an error, if no contamination was detectable.

#### Identification of contamination

The samples were each repeated for all four treatments. In the case of a discrepancy between the original genotype and the 're-used PCR plate' or 're-used detection plate' treatment, the new genotype was compared to the genotype of the individual previously genotyped in the same well. If the genotype matched the genotype of the original individual, the mis-matched was marked as contamination.

### Data

The data for this project are the raw sequencing reads from the ABI 3730xl capillary sequencer. Each files is identified with the following name structure: RackX_mixY_Z. Where X gives the rack number, Y the mix and Z the treatment (1 = standard procedure, 2 = internal control, 3 = Re-used PCR plate and 4 = Re-used detection plate).

```{r}
#| label: data
#| echo: FALSE

#make list with path to all files
Data_files <- list.files(path = "Data/Working_data", pattern = "*.csv", full.names = T) 
Mix1_locate <- grep("mix1", Data_files)
Mix1 <- Data_files[Mix1_locate]

Data_list = list()
#Broken well
remove_row <- c("E03_Empty")

#for loop which reads the csv files, removes the broken well and collects the dataframes in one list for mix 1
for(i in Data_files[Mix1_locate]) {
  x <- read.csv(i, sep = ";")
  x <- subset(x, ID != remove_row)
  Data_list[[i]] <- x
  #The following line tidies up the names of the files
   names(Data_list) <- gsub("Data/Working_data/AP_AFS_|AFS|_\\d{2}|_AlleleReport.csv", "", names(Data_list))
   names(Data_list) <- gsub("Data/Working_data/ALB__|AFS_|_\\d{2}|_AlleleReport.csv", "", names(Data_list))
}

#for loop which reads the csv files, removes the broken well and the columns 'rack_location' and 'id' and collects the dataframes in one list for other mixes than mix one. 
for(i in Data_files[-Mix1_locate]) {
  x <- read.csv(i, sep = ";")
  x <- subset(x, ID != remove_row, select = -c(Rack_location, ID))
  Data_list[[i]] <- x
  #The following line tidies up the names of the files
  names(Data_list) <- gsub("Data/Working_data/AP_AFS_|AFS|_\\d{2}|_AlleleReport.csv", "", names(Data_list))
  names(Data_list) <- gsub("Data/Working_data/ALB__|AFS_|_\\d{2}|_AlleleReport.csv", "", names(Data_list))
  }

#The loci ZcwCO1 in mix 2 and ZcwCO3 in mix five is the same locus. Therefore, they need to be merged and the second version removed

ZcwCO1_loci <- function(DF) {
  #ZcwCO1
  change_a <- which(DF$mix2.ZcwCO1_a != DF$mix5.ZcwC03_a | is.na(DF$mix2.ZcwCO1_a) == T)
  change_b <- which(DF$mix2.ZcwCO1_b != DF$mix5.ZcwC03_b | is.na(DF$mix2.ZcwCO1_b) == T)
  DF$mix2.ZcwCO1_a[change_a] <- DF$mix5.ZcwC03_a[change_a]
  DF$mix2.ZcwCO1_b[change_b] <- DF$mix5.ZcwC03_b[change_b]
  DF <- subset(DF, select = -c(mix5.ZcwC03_a, mix5.ZcwC03_b))
}

Mangs_loci <- function(DF) {
  #Mangs
  Mangs44_a <- which(DF$mix5.Mang44_a != DF$Mangs.Mang44_a | is.na(DF$mix5.Mang44_a) == T)
  Mangs44_b <- which(DF$mix5.Mang44_b != DF$Mangs.Mang44_b | is.na(DF$mix5.Mang44_b) == T)
  Mangs36_a <- which(DF$mix5.Mang36_a != DF$Mangs.Mang36_a | is.na(DF$mix5.Mang36_a) == T)
  Mangs36_b <- which(DF$mix5.Mang36_b != DF$Mangs.Mang36_b | is.na(DF$mix5.Mang36_b) == T)
  DF$mix5.Mang44_a[Mangs44_a] <- DF$Mangs.Mang44_a[Mangs44_a]
  DF$mix5.Mang44_b[Mangs44_b] <- DF$Mangs.Mang44_b[Mangs44_b]
  DF$mix5.Mang36_a[Mangs36_a] <- DF$Mangs.Mang36_a[Mangs36_a]
  DF$mix5.Mang36_b[Mangs36_b] <- DF$Mangs.Mang36_b[Mangs36_b]
  DF <- subset(DF, select = -c(Mangs.Mang44_a, Mangs.Mang44_b, Mangs.Mang36_a, Mangs.Mang36_b))
}
#bind the different mixes together
Data_df = do.call(cbind, Data_list)
#Separate the dataframe into Rack and treatment and remove this info from column names
R154_R1 <- Data_df %>% select(contains("Rack154")) %>% select(contains("_1")) %>%
  rename_with(~sub("Rack154_", "", .), everything()) %>% 
  rename_with(~sub("_1", "", .), everything()) %>% ZcwCO1_loci() %>% Mangs_loci()
R154_R2 <- Data_df %>% select(contains("Rack154")) %>% select(contains("_2")) %>%
  rename_with(~sub("Rack154_", "", .), everything()) %>%
  rename_with(~sub("_2", "", .), everything()) %>% ZcwCO1_loci()
R154_R3 <- Data_df %>% select(contains("Rack154")) %>% select(contains("_3")) %>%
  rename_with(~sub("Rack154_", "", .), everything()) %>%
  rename_with(~sub("_3", "", .), everything()) %>% ZcwCO1_loci()
R154_R4 <- Data_df %>% select(contains("Rack154")) %>% select(contains("_4")) %>%
  rename_with(~sub("Rack154_", "", .), everything()) %>%
  rename_with(~sub("_4", "", .), everything()) %>% ZcwCO1_loci()
R155_R1 <- Data_df %>% select(contains("Rack155")) %>% select(contains("_1")) %>%
  rename_with(~sub("Rack155_", "", .), everything()) %>%
  rename_with(~sub("_1", "", .), everything()) %>% ZcwCO1_loci() %>% Mangs_loci()
R155_R2 <- Data_df %>% select(contains("Rack155")) %>% select(contains("_2")) %>%
  rename_with(~sub("Rack155_", "", .), everything()) %>%
  rename_with(~sub("_2", "", .), everything()) %>% ZcwCO1_loci()
R155_R3 <- Data_df %>% select(contains("Rack155")) %>% select(contains("_3")) %>%
  rename_with(~sub("Rack155_", "", .), everything()) %>%
  rename_with(~sub("_3", "", .), everything()) %>% ZcwCO1_loci()
R155_R4 <- Data_df %>% select(contains("Rack155")) %>% select(contains("_4")) %>%
  rename_with(~sub("Rack155_", "", .), everything()) %>%
  rename_with(~sub("_4", "", .), everything()) %>% ZcwCO1_loci()
R156_R1 <- Data_df %>% select(contains("Rack156")) %>% select(contains("_1")) %>%
  rename_with(~sub("Rack156_", "", .), everything()) %>%
  rename_with(~sub("_1", "", .), everything()) %>% ZcwCO1_loci() %>% Mangs_loci()
R156_R2 <- Data_df %>% select(contains("Rack156")) %>% select(contains("_2")) %>%
  rename_with(~sub("Rack156_", "", .), everything()) %>%
  rename_with(~sub("_2", "", .), everything()) %>% ZcwCO1_loci()
R156_R3 <- Data_df %>% select(contains("Rack156")) %>% select(contains("_3")) %>%
  rename_with(~sub("Rack156_", "", .), everything()) %>%
  rename_with(~sub("_3", "", .), everything()) %>% ZcwCO1_loci()
R156_R4 <- Data_df %>% select(contains("Rack156")) %>% select(contains("_4")) %>%
  rename_with(~sub("Rack156_", "", .), everything()) %>%
  rename_with(~sub("_4", "", .), everything()) %>% ZcwCO1_loci()

rm(Data_df, Data_list, x, Data_files, i, Mix1, Mix1_locate, remove_row)
```

Before starting the error rate evaluation, the no. of genotypes that could no be scored for each round and mix per rack is tabulated (See @tbl-failed).

```{r}
#| label: Failed samples
#| echo: FALSE
#| tbl-cap: Failed genotypes {#tbl-failed}
#The Count_NAs function counts the total and per mix number of NAs in a dataframe. 
#NAs cover all cases where a allele could not be scored, whatever the reason
#Reasons include but are not limited to: PCR failing, poor DNA quality, unambiguous genotypes
Count_NAs <- function(DF) {
  Mix1 <- sum(is.na(select(DF, contains("mix1"))))
  Mix2 <- sum(is.na(select(DF, contains("mix2"))))
  Mix3 <- sum(is.na(select(DF, contains("mix3"))))
  Mix4 <- sum(is.na(select(DF, contains("mix4"))))
  Mix5 <- sum(is.na(select(DF, contains("mix5"))))
  Total <- sum(is.na(DF))
  Rack <- deparse(substitute(DF))
  Output <- rbind(Mix1, Mix2, Mix3, Mix4, Mix5,Total)
  colnames(Output) <- Rack
  return(Output)
}

Failed_samples <- as.data.frame(cbind(Count_NAs(R154_R1), Count_NAs(R154_R2), Count_NAs(R154_R3), Count_NAs(R154_R4), Count_NAs(R155_R1), Count_NAs(R155_R2), Count_NAs(R155_R3), Count_NAs(R155_R4), Count_NAs(R156_R1), Count_NAs(R156_R2), Count_NAs(R156_R3), Count_NAs(R156_R4))) 
Failed_samples <- tibble::rownames_to_column(Failed_samples, "Mix")

#Save the table as a csv file
write_csv(Failed_samples, file.path(tabs_dir, "Failed_genotypes.csv"))

knitr::kable(Failed_samples)
```

In @fig-Heatmap, the location of the missing data on the plate is visualized. More purple hues correspond to more missing loci for that particular samples, and we can conclude that certain samples seem to have failed almost completely. This could hint at poor DNA quality. The data is arranged in the plot to match the layout of the actual plate. Through visual inspection, there might be a slight tendency for the missing loci to be located more towards the edges of the plates compared to the center.

```{r}
#| label: fig-Heatmap
#| echo: FALSE
#| warning: FALSE
#| fig-cap: "Heatmap of missing data"

#Fix this in initial read in
R156_R1$mix5.Mang44_a <- as.integer(R156_R1$mix5.Mang44_a)
R156_R3$mix3.ZcwDz301_a <- as.integer(R156_R3$mix3.ZcwDz301_a)
R156_R3$mix3.ZcwDh4.7_a <- as.integer(R156_R3$mix3.ZcwDh4.7_a)

#The replace functions locates NAs and replaces them with 0 and all other entries with 1
Replace <- function(DF) {
  mix <- DF %>% replace(!is.na(.), 1) %>% replace(is.na(.), 0) %>%
  mutate(Row_Sums = rowSums(across(everything())))
  Sum <- mix$Row_Sums
  return(Sum)
}

#The heatmap function generates a heatmap for the dataframe provided
Heatmap <- function(DF) {
  #using the replace function, the sum per ID of scored loci is calculated
  Sum <- as.data.frame(cbind(Replace(DF[3:18]), Replace(DF[19:36]), Replace(DF[37:52]), Replace(DF[53:64]), Replace(DF[65:80]))) %>% mutate(Sums = rowSums(across(everything())))
  
  #Name
  Rack <- deparse(substitute(DF))
  
  #In some of the racks, a couple of samples have been repeated (_1 and _2), cleans name
  DF$mix1.ID <- gsub("_(\\d)$", "", as.character(DF$mix1.ID))
  
  #Creates the table needed for ggplot to generate the heatmap
  Heat <- as.data.frame(cbind(Sum$Sums, DF$mix1.ID, DF$mix1.ID)) 
  colnames(Heat) <- c("Sum", "Column", "Row")
  Heat <- Heat %>%
    mutate(Row = gsub("\\d{2}_[A-Z]{3}\\d{5}", "", as.character(Row)),
         Column = gsub("[A-Z]|_[A-Z]{3}\\d{5}", "", as.character(Column))) %>%
    mutate(Row = as.factor(Row), Sum = as.numeric(Sum))
  
  #The actual plot, data entered to represent the layout of the actual plate
  #More purple hues means more missing data
  Heatmap.plot <- ggplot(data = Heat, aes(x=factor(Column, level=c('01','02','03','04','05','06','07','08','09','10','11','12')), y=Row, fill=Sum)) +
  geom_tile() +
  scale_y_discrete(limits = rev(levels(Heat$Row))) +
  scale_fill_gradient(low = "purple", high = "orange", limits = c(0,80)) +
  theme_minimal() +
  theme(axis.title.x = element_blank(),
        axis.title.y = element_blank()) +
  ggtitle(Rack)
  return(Heatmap.plot)
}

#Applying the heatmap funtion to all datasets and arranging them 
Heatmap.plot <- plot_grid(Heatmap(R154_R1), Heatmap(R155_R1), Heatmap(R156_R1), 
                          Heatmap(R154_R2), Heatmap(R155_R2), Heatmap(R156_R2),
                          Heatmap(R154_R3), Heatmap(R155_R3), Heatmap(R156_R3), 
                          Heatmap(R154_R4), Heatmap(R155_R4), Heatmap(R156_R4), 
                          labels = NULL, nrow = 4)

#Heatmap.plot 
ggsave(plot = Heatmap.plot, filename = file.path(figs_dir, "Heatmap.png"), width = 30, height = 21, unit = "cm", dpi = 500)
```

![Heatmap of missing data](Results/Figures/Heatmap.png){#fig-Heatmap}

#### Error rate calculation

The error rate is calculated by comparing all scored alleles and genotypes from the standard procedure within one rack with the other treatments starting with the internal control. The internal control is included as a baseline for error rates to have a comparable metric to evaluate if the reused plates inflate the error rate.

```{r}
#| label: Allelic errors
#| echo: FALSE
#| tbl-cap: Allelic mismatches {#tbl-allelemismatch}
#Function to compare scored alleles between two rounds and find the mismatches
#The function has two output lines. These cannot work in tandem. 
#The first return statement returns the total mismatches and error rate
#The second return statement can be used with "Find_mismatches" to locate mismatch in Genemarker
Mismatch <- function(DF1, DF2){
  #locate the mismatches by comparing the two data frames and count them
  mismatches <- which(DF1 != DF2, arr.ind = TRUE)
  Total_mismatches <- length(mismatches[,1])
  
  #To recognize treatment, simplify the 'name' of the DF to the round number (R*)
  Rack_1 <- deparse(substitute(DF1))
  Rack_2 <- deparse(substitute(DF2))
  Round <- gsub("R\\d{3}|_", "", Rack_2)
  if (Round == "R2"){
    Treatment <- "Internal control"
  } else if (Round == "R3") {
    Treatment <- "Re-used PCR"
  } else {
    Treatment <- "Re-used detection plate"
  }
  
  #The allelic error rate is calculated by dividing the number of errors with 
  #the total number of comparision made between the two dataframes
  Total_comparisons <- sum(!is.na(DF1[3:80]) & !is.na(DF2[3:80]))
  #cat("Total mismatches between", Rack_1 ,"and", Rack_2, "=", Total_mismatches)
  Error_rate <- Total_mismatches/Total_comparisons  
  
  #The Output is a data frame with the results
  Output <- as.data.frame(cbind(Rack_1, Rack_2, Treatment, Total_mismatches, Error_rate)) %>%
         mutate(Total_mismatches = as.numeric(Total_mismatches),
         Error_rate = as.numeric(Error_rate))
  colnames(Output) <- c("Rack 1", "Rack 2", "Treatment", "No. of mismatches", "Allelic error rate")
  return(Output)
  
  #Second output element! # out return statement when not in use. 
  #The ID of the individual with the mismatch and the loci werein the mismatch happend 
  #is bound together to ease location 
  ID <- cbind(DF1$mix1.ID[mismatches[, 1]])
  Loci <- cbind(colnames(DF1)[mismatches[, 2]])
  Find_mismatch <- cbind(ID, Loci, Rack_2, Treatment)
  #return(Find_mismatch)
}

#The following applies the mismatch function to the chosen racks and binds the output together
#The output contains the mismatches and the error rate
Mismatches <- bind_rows(
  Mismatch(R154_R1, R154_R2),
  Mismatch(R154_R1, R154_R3),
  Mismatch(R154_R1, R154_R4),
  Mismatch(R155_R1, R155_R2),
  Mismatch(R155_R1, R155_R3),
  Mismatch(R155_R1, R155_R4),
  Mismatch(R156_R1, R156_R2),
  Mismatch(R156_R1, R156_R3),
  Mismatch(R156_R1, R156_R4)) %>% arrange(factor(Treatment, levels = c("Internal control", "Re-used PCR", "Re-used detection plate")))

knitr::kable(Mismatches, row.names = F)

Total_Mcases <- sum(Mismatches$`No. of mismatches`)
#The following applies the mismatch function to the chosen racks and binds the output together
#The output contains the location of the mismatches
#Find_mismatches <- rbind(
  #Mismatch(R154_R1, R154_R2),
  #Mismatch(R154_R1, R154_R3),
  #Mismatch(R154_R1, R154_R4),
  #Mismatch(R155_R1, R155_R2),
  #Mismatch(R155_R1, R155_R3),
  #Mismatch(R155_R1, R155_R4),
  #Mismatch(R156_R1, R156_R2),
  #Mismatch(R156_R1, R156_R3),
  #Mismatch(R156_R1, R156_R4))
```

#### Inspect mismatches for contamination

The comparison between the different treatments and the standard procedure yielded a list of mismatches. To identify whether these mismatches in the case of the 're-used PCR plate' and 're-used detection plate' treatment was due to contamination from the samples previous found in the same well, the new genotype was compared to the original genotype scored from that well. If the genotype matched the original genotype, the mis-match was marked as potential case of contamination.

```{r}
#| label: contamination
#| echo: FALSE
#| tbl-cap: Potential contamination cases {#tbl-contamination}
#To inspect mismatches for potential contamination we use the detect_contamination function. 
#R1 is the standard procedure plate from a given rack
#Reused is either the reused PCR or reused detection plate treatment 
#Control is the outcome of the standard procedure plate that was cleaned (and later reused) to the corresponding rack number. 
Detect_contamination <- function(R1, Reused, Control){
  mismatches <- which(R1 != Reused, arr.ind = TRUE)
  Potential_contamination <- mismatches[Reused[mismatches] == Control[mismatches],] 
  Cases <- length(Potential_contamination)/2
  
  #Get name of dataframes
  Rack_1 <- deparse(substitute(R1))
  Rack_2 <- deparse(substitute(Reused))
  Rack_3 <- deparse(substitute(Control))
  #cat("The total no. of mismatches between", Rack_1 ,"and", Rack_2, "is", length(mismatches[,1]), "whereof", Cases, "cases match with the control plate:", Rack_3)
  
  #Output 
  Output <- as.data.frame(cbind(Rack_2, Rack_3, Cases)) %>% mutate(Cases = as.numeric(Cases))
  colnames(Output) <- c("Rack", "Control", "Cases")
  return(Output)
  #If we want to quickly locate the specific cases
  ID <- cbind(Reused$mix1.ID[Potential_contamination[, 1]])
  Loci <- cbind(colnames(Reused)[Potential_contamination[, 2]])
  Find_contamination <- cbind(ID, Loci, Rack_2)
  #return(Find_contamination)
}

Contamination_cases <- bind_rows(Detect_contamination(R154_R1, R154_R3, R156_R1), Detect_contamination(R154_R1, R154_R4, R156_R1), Detect_contamination(R155_R1, R155_R3, R154_R1), Detect_contamination(R155_R1, R155_R4, R154_R1), Detect_contamination(R156_R1, R156_R3, R155_R1), Detect_contamination(R156_R1, R156_R4, R155_R1))
knitr::kable(Contamination_cases, row.names = F)

Total_Ccases <- sum(Contamination_cases$Cases)
```

### Analysis

To determine if treatment had a significant effect on the following three measures; no. of mismatches, allelic error rate and potential cases of contamination, we performed ANOVAs followed by a post hoc test for pairwise comparisons for the three treatment groups measured against the standard procedure treatment.

```{r}
#| label: Mismatch_analysis
#| echo: FALSE

M.mismatches <- aov(`No. of mismatches` ~ Treatment, data = Mismatches)
summary(M.mismatches)

TukeyHSD(M.mismatches, conf.level=.95) 
#Detection plate treatment significantly different from the other two
```

The total no. of mismatches between the standard procedure and the additional treatments could be significantly determined by treatment. Further exploration using a Tukey pairwise comparison revealed that this treatment effect was driven by a significant difference in no. of mismatches in the 're-used detection plate' treatment when compared to both the internal control and the re-used PCR treatment. When comparing those two treatments to eachother, no significant difference could be found. The same was true for the error rate.

```{r}
#| label: errorrate_analysis
#| echo: FALSE

M.errorrate <- aov(`Allelic error rate` ~ Treatment, data = Mismatches)
summary(M.errorrate)

TukeyHSD(M.errorrate, conf.level=.95)
#Detection plate treatment significantly different from the other two
```

To explore the effect of treatment on the number of potential contamination cases, a non-parametric wilcoxon test was used.

*Note: the test is performed on only one case of the 're-used detection plate' treatment and therefore not yet considered informative.*

```{r}
#| label: contamination_analysis
#| echo: FALSE

Contamination_cases$Treatment <- c("Re-used PCR", "Re-used detection plate", "Re-used PCR")
#Wilcox.test compares two non-parametric groups. 
#Null-hypothesis is that the two medians are equal. Lacks the other cases to fully interpret
wilcox.test(Cases ~ Treatment, data = Contamination_cases)
```

# Results

Will come later

@fig-allelicerrors shows the total no. of mismatches observed when comparing the standard procedure treatment of each rack with the other treatments.

```{r}
#| label: fig-allelicerrors
#| echo: FALSE
#| warning: FALSE
#| fig-cap: "Allelic mismatches"
Mismatchplot <- Mismatches %>% 
  mutate(Treatment = fct_relevel(Treatment, 
            "Internal control", "Re-used PCR", "Re-used detection plate")) %>%
  ggplot( aes(y=`No. of mismatches`, x = Treatment, fill = `Rack 2`)) +
  geom_bar(stat = "identity", position = position_dodge(), width = 0.5, alpha = 0.8) +
  scale_fill_brewer(palette = "YlGn") +
  guides(fill = F, scale = "none") + #remove the legend
  geom_text(aes(label = `Rack 2`), vjust = -0.4, position = position_dodge(0.5), size = 2.5) + #adds the rack name to the bar, vjust pushes the text above the bar
  ylim(0,140) +
  ggtitle("Total no. of mismatches") +
  theme_bw()

Mismatchplot
```

```{r}
#| label: fig-errorrate
#| echo: FALSE
#| warning: FALSE
#| fig-cap: "Allelic error rate"

Errorrateplot <- Mismatches %>% 
  mutate(Treatment = fct_relevel(Treatment, 
            "Internal control", "Re-used PCR", "Re-used detection plate")) %>%
ggplot( aes(x=Treatment, y=`Allelic error rate`, fill = Treatment)) + 
  geom_boxplot(alpha = 0.8) +
  scale_fill_brewer(palette = "Greens") +
  theme(legend.position = "none") +
  guides(fill = F, scale = "none") + #remove the legend
  ggtitle("Allelic error rate") +
  theme_bw()

Errorrateplot
```

We found a total of `r Total_Mcases` mismatches between all treatments. A subset of these (`r Total_Ccases`) were potential contamination cases.

```{r}
#| label: fig-contamination
#| echo: FALSE
#| warning: FALSE
#| fig-cap: "Potential contamination"

Contaminationplot <- ggplot(data = Contamination_cases, aes(y=Cases, x = Rack, fill = Rack)) +
  geom_bar(stat = "identity", position = position_dodge(), width = 0.5, alpha = 0.8) +
  scale_fill_brewer(palette = "Greens") + 
  guides(fill = F, scale = "none") + #remove the legend
  geom_text(aes(label = Cases), vjust = -0.4, position = position_dodge(0.5), size = 3.5) + #adds the rack name to the bar, vjust pushes the text above the bar
  ylim(0,120) +
  ggtitle("Total no. of potential contamination cases") +
  theme_bw()

Contaminationplot
```

```{r}
#| label: Gapfilling
#| echo: FALSE
# 
# #This function can be used to locate the plates that needs to be gapfilled
# Failed_loci <- function(DF1){
#   #mix 1
#   Pv9 <- sum(is.na(select(DF1, contains("Pv9"))))
#   Hg.6.3 <- sum(is.na(select(DF1, contains("Hg.6.3"))))
#   Hg.8.10 <- sum(is.na(select(DF1, contains("Hg.8.10"))))
#   Hg.1.3 <- sum(is.na(select(DF1, contains("Hg.1.3"))))
#   M11a <- sum(is.na(select(DF1, contains("M11a"))))
#   PvcA <- sum(is.na(select(DF1, contains("PvcA"))))
#   Zcwb07 <- sum(is.na(select(DF1, contains("Zcwb07"))))
#   Agaz2 <- sum(is.na(select(DF1, contains("Agaz2"))))
#   loci_m1 <- as.data.frame(rbind(Pv9, Hg.6.3, Hg.8.10, Hg.1.3, M11a, PvcA, Zcwb07, Agaz2))
#   loci_m1$Mix <- "Mix1"
#   #mix 2
#   Ag3 <- sum(is.na(select(DF1, contains("Ag3"))))
#   Agaz6 <- sum(is.na(select(DF1, contains("Agaz6"))))
#   OrrFCB7 <- sum(is.na(select(DF1, contains("OrrFCB7"))))
#   Ag2 <- sum(is.na(select(DF1, contains("Ag2"))))
#   OrrFCB2 <- sum(is.na(select(DF1, contains("OrrFCB2"))))
#   Lw10 <- sum(is.na(select(DF1, contains("Lw10"))))
#   ZcwCO1 <- sum(is.na(select(DF1, contains("ZcwCO1"))))
#   Agaz5 <- sum(is.na(select(DF1, contains("Agaz5"))))
#   ZcwDhB <- sum(is.na(select(DF1, contains("ZcwDhB"))))
#   loci_m2 <- as.data.frame(rbind(Ag3, Agaz6, OrrFCB7, Ag2, OrrFCB2, Lw10, ZcwCO1, Agaz5, ZcwDhB))
#   loci_m2$Mix <- "Mix2"
#   #mix 3
#   ZcwDz301 <- sum(is.na(select(DF1, contains("ZcwDz301"))))
#   Ag7 <- sum(is.na(select(DF1, contains("Ag7"))))
#   Ag.10 <- sum(is.na(select(DF1, contains("Ag.10"))))
#   ZcwDh4 <- sum(is.na(select(DF1, contains("ZcwDh4"))))
#   ZcwE05 <- sum(is.na(select(DF1, contains("ZcwE05"))))
#   Ag1 <- sum(is.na(select(DF1, contains("Ag1"))))
#   OrrFCB8 <- sum(is.na(select(DF1, contains("OrrFCB8"))))
#   Agt.47 <- sum(is.na(select(DF1, contains("Agt.47"))))
#   loci_m3 <- as.data.frame(rbind(ZcwDz301, Ag7, Ag.10, ZcwDh4, ZcwE05, Ag1, OrrFCB8, Agt.47))
#   loci_m3$Mix <- "Mix3"
#   #mix 4
#   ZcwF07 <- sum(is.na(select(DF1, contains("ZcwF07"))))
#   ZcwD02 <- sum(is.na(select(DF1, contains("ZcwD02"))))
#   ZcwCgDh1 <- sum(is.na(select(DF1, contains("ZcwCgDh1"))))
#   Aa4 <- sum(is.na(select(DF1, contains("Aa4"))))
#   ZcCgDH5.8 <- sum(is.na(select(DF1, contains("ZcCgDH5.8"))))
#   Agaz3 <- sum(is.na(select(DF1, contains("Agaz3"))))
#   loci_m4 <- as.data.frame(rbind(ZcwF07, ZcwD02, ZcwCgDh1, Aa4, ZcCgDH5.8, Agaz3))
#   loci_m4$Mix <- "Mix4"
#   #mix 5
#   X962.1 <- sum(is.na(select(DF1, contains("X962.1"))))
#   X554.6 <- sum(is.na(select(DF1, contains("X554.6"))))
#   ZcwA12 <- sum(is.na(select(DF1, contains("ZcwA12"))))
#   PvcE <- sum(is.na(select(DF1, contains("PvcE"))))
#   ZcwB09 <- sum(is.na(select(DF1, contains("ZcwB09"))))
#   Agaz10 <- sum(is.na(select(DF1, contains("Agaz10"))))
#   Mang44 <- sum(is.na(select(DF1, contains("Mang44"))))
#   Mang36 <- sum(is.na(select(DF1, contains("Mang36"))))
#   loci_m5 <- as.data.frame(rbind(X962.1, X554.6, ZcwA12, PvcE, ZcwB09, Agaz10, Mang44, Mang36))
#   loci_m5$Mix <- "Mix5"
#   #Create the output
#   Rack <- deparse(substitute(DF1))
#   Samples <- 95
#   Output <- as.data.frame(rbind(loci_m1,loci_m2, loci_m3, loci_m4, loci_m5))
#   colnames(Output) <- c("Unscored", "Mix")
#   Rack <- deparse(substitute(DF1))
#   Output$Rack <- Rack
#   #Calculates the percentage of unscored loci rounded to 2 digits
#   Output$Percent <- as.numeric((as.numeric(Output$Unscored)/Samples*0.5)*100) %>%
#     round(., 2)
#   Output$Loci <- rownames(Output)
#   #return(Output)
#   #alternatively if only interested in failed loci, loci with more than 20% NAs
#   Find_failed_loci <- subset(Output, Output$Percent > 20)
#   rownames(Find_failed_loci) <- NULL
#   return(Find_failed_loci)
# }
# 
# #apply failed_loci function to all racks to locate which plates needs gapfilling
# Gapfilling <- rbind(Failed_loci(R154_R1), 
#                           Failed_loci(R154_R2), 
#                           Failed_loci(R154_R3), 
#                           Failed_loci(R154_R4), 
#                           Failed_loci(R155_R1), 
#                           Failed_loci(R155_R2), 
#                           Failed_loci(R155_R3),
#                           Failed_loci(R155_R4),
#                           Failed_loci(R156_R1),
#                           Failed_loci(R156_R2),
#                           Failed_loci(R156_R3),
#                           Failed_loci(R156_R4))
# Gapfilling <- Gapfilling[order(Gapfilling$Rack,Gapfilling$Mix ),]
# 
# #saves the table in the correct folder
# write_csv(Gapfilling, file.path(tabs_dir, "Gapfilling.csv"))
```

```{r}
#| label: Maybeusablecode
#| echo: FALSE
# Row1 <- R154_R1[grep('A\\d', R154_R1$mix1.ID), ] %>% 
#   select(contains("Mix1")) %>%
#   replace(is.na(.), 0) %>%
#   as.data.frame() %>%
#   mutate_all(~ ifelse(. == '0', 0, 1)) %>%
#   mutate(Row_Sums = rowSums(.[3:18])) %>%
#   pull(Row_Sums)
# Row2 <- R154_R1[grep('B\\d', R154_R1$mix1.ID), ] %>% 
#   select(contains("Mix1")) %>%
#   replace(is.na(.), 0) %>%
#   as.data.frame() %>%
#   mutate_all(~ ifelse(. == '0', 0, 1)) %>%
#   mutate(Row_Sums = rowSums(across(everything()))) %>%
#   pull(Row_Sums)
# Row3 <- R154_R1[grep('C\\d', R154_R1$mix1.ID), ] %>%   
#   select(contains("Mix1")) %>%
#   replace(is.na(.), 0) %>%
#   as.data.frame() %>%
#   mutate_all(~ ifelse(. == '0', 0, 1)) %>%
#   mutate(Row_Sums = rowSums(across(everything()))) %>%
#   pull(Row_Sums)
# Row4 <- R154_R1[grep('D\\d', R154_R1$mix1.ID), ] %>%   
#   select(contains("Mix1")) %>%
#   replace(is.na(.), 0) %>%
#   as.data.frame() %>%
#   mutate_all(~ ifelse(. == '0', 0, 1)) %>%
#   mutate(Row_Sums = rowSums(across(everything()))) %>%
#   pull(Row_Sums)
# Row5 <- R154_R1[grep('E\\d', R154_R1$mix1.ID), ] %>%   
#   select(contains("Mix1")) %>%
#   replace(is.na(.), 0) %>%
#   as.data.frame() %>%
#   mutate_all(~ ifelse(. == '0', 0, 1)) %>%
#   mutate(Row_Sums = rowSums(across(everything()))) %>%
#   pull(Row_Sums)
# Row6 <- R154_R1[grep('F\\d', R154_R1$mix1.ID), ] %>%   
#   select(contains("Mix1")) %>%
#   replace(is.na(.), 0) %>%
#   as.data.frame() %>%
#   mutate_all(~ ifelse(. == '0', 0, 1)) %>%
#   mutate(Row_Sums = rowSums(across(everything()))) %>%
#   pull(Row_Sums)
# Row7 <- R154_R1[grep('G\\d', R154_R1$mix1.ID), ] %>%   
#   select(contains("Mix1")) %>%
#   replace(is.na(.), 0) %>%
#   as.data.frame() %>%
#   mutate_all(~ ifelse(. == '0', 0, 1)) %>%
#   mutate(Row_Sums = rowSums(across(everything()))) %>%
#   pull(Row_Sums)
# Row8 <- R154_R1[grep('H\\d', R154_R1$mix1.ID), ] %>%
#   select(contains("Mix1")) %>%
#   replace(is.na(.), 0) %>%
#   as.data.frame() %>%
#   mutate_all(~ ifelse(. == '0', 0, 1)) %>%
#   mutate(Row_Sums = rowSums(across(everything()))) %>%
#   pull(Row_Sums)
# 
# Missing_data <- as.data.frame(rbind(Row1, Row2, Row3, Row4, Row5, Row6, Row7, Row8))
# #Missing_data <- matrix(as.numeric(unlist(Missing_data)),nrow=nrow(Missing_data))
# #heatmap(Missing_data, Rowv = NA, Colv = NA)
# Missing_data$row <- rbind("row1", "row2", "row3", "row4", "row5", "row6", "row7", "row8")
```
